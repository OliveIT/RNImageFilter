import { setType } from "../fable-core/Symbol";
import _Symbol from "../fable-core/Symbol";
import { view as view_1, disabledView, update as update_1, init as init_1, Message as Message_1, Model as Model_1 } from "./FilterRangeInput";
import { compareUnions, equals, compareRecords, equalsRecords } from "../fable-core/Util";
import { printf, toText } from "../fable-core/String";
import List from "../fable-core/List";
import { Cmd } from "../fable/cmd";
import { Fragment, createElement } from "react";
export class Model {
  constructor(animated, step, direction) {
    this.Animated = animated;
    this.Step = step;
    this.Direction = direction;
  }

  [_Symbol.reflection]() {
    return {
      type: "MatrixFilterConstructor.AnimatedFilterRangeInput.Model",
      interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
      properties: {
        Animated: Model_1,
        Step: Model_1,
        Direction: "number"
      }
    };
  }

  Equals(other) {
    return equalsRecords(this, other);
  }

  CompareTo(other) {
    return compareRecords(this, other) | 0;
  }

}
setType("MatrixFilterConstructor.AnimatedFilterRangeInput.Model", Model);
export class Message {
  constructor(tag, data) {
    this.tag = tag | 0;
    this.data = data;
  }

  [_Symbol.reflection]() {
    return {
      type: "MatrixFilterConstructor.AnimatedFilterRangeInput.Message",
      interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
      cases: [["StepMessage", Message_1], ["Tick"]]
    };
  }

  Equals(other) {
    return this === other || this.tag === other.tag && equals(this.data, other.data);
  }

  CompareTo(other) {
    return compareUnions(this, other) | 0;
  }

}
setType("MatrixFilterConstructor.AnimatedFilterRangeInput.Message", Message);
export function init(name, min, max, initial) {
  const minStep = Math.abs(max) / 1000;
  const maxStep = Math.abs(max) / 10;
  return new Model(init_1(name, min, max, initial), init_1(toText(printf("Step.%s"))(name), minStep, maxStep, minStep), 1);
}
export function update(message, model) {
  if (message.tag === 1) {
    const nextValue = Math.max(model.Animated.Min, Math.min(model.Animated.Max, model.Animated.Value + model.Direction * model.Step.Value));
    const nextDirection = nextValue === model.Animated.Min ? 1 : nextValue === model.Animated.Max ? -1 : model.Direction;
    return [new Model(new Model_1(nextValue, model.Animated.Min, model.Animated.Max, model.Animated.Name), model.Step, nextDirection), new List()];
  } else {
    const patternInput = update_1(message.data, model.Step);
    return [new Model(model.Animated, patternInput[0], model.Direction), Cmd.map(function (arg0) {
      return new Message(0, arg0);
    }, patternInput[1])];
  }
}
export function view(model, dispatch) {
  return createElement(Fragment, {}, disabledView(model.Animated), view_1(model.Step, $var1 => dispatch(function (arg0) {
    return new Message(0, arg0);
  }($var1))));
}