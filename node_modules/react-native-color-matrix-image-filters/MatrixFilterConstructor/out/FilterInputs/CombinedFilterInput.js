import { setType } from "../fable-core/Symbol";
import _Symbol from "../fable-core/Symbol";
import { compareUnions, equals, GenericParam } from "../fable-core/Util";
import { view as view_3, update as update_3, init } from "./FilterRangeInput";
import { view as view_1, update as update_1, init as init_1 } from "./FilterColorInput";
import { view as view_2, update as update_2, init as init_2 } from "./AnimatedFilterRangeInput";
import { Cmd } from "../fable/cmd";
import List from "../fable-core/List";
export class Shape {
  constructor(tag, data) {
    this.tag = tag | 0;
    this.data = data;
  }

  [_Symbol.reflection]() {
    return {
      type: "MatrixFilterConstructor.CombinedFilterInput.Shape",
      interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
      cases: [["Range", GenericParam("range")], ["Color", GenericParam("color")], ["Animated", GenericParam("animated")]]
    };
  }

  Equals(other) {
    return this === other || this.tag === other.tag && equals(this.data, other.data);
  }

  CompareTo(other) {
    return compareUnions(this, other) | 0;
  }

}
setType("MatrixFilterConstructor.CombinedFilterInput.Shape", Shape);
export function initRange(min, max, initial, name) {
  return new Shape(0, init(name, min, max, initial));
}
export function initColor(initial, name) {
  return new Shape(1, init_1(name, initial));
}
export function initAnimated(min, max, initial, name) {
  return new Shape(2, init_2(name, min, max, initial));
}
export function update(message, model) {
  const matchValue = [model, message];

  if (matchValue[0].tag === 1) {
    if (matchValue[1].tag === 1) {
      const patternInput = update_1(matchValue[1].data, matchValue[0].data);
      return [new Shape(1, patternInput[0]), Cmd.map(function (arg0) {
        return new Shape(1, arg0);
      }, patternInput[1])];
    } else {
      return [model, new List()];
    }
  } else if (matchValue[0].tag === 2) {
    if (matchValue[1].tag === 2) {
      const patternInput_1 = update_2(matchValue[1].data, matchValue[0].data);
      return [new Shape(2, patternInput_1[0]), Cmd.map(function (arg0_1) {
        return new Shape(2, arg0_1);
      }, patternInput_1[1])];
    } else {
      return [model, new List()];
    }
  } else if (matchValue[1].tag === 0) {
    const patternInput_2 = update_3(matchValue[1].data, matchValue[0].data);
    return [new Shape(0, patternInput_2[0]), Cmd.map(function (arg0_2) {
      return new Shape(0, arg0_2);
    }, patternInput_2[1])];
  } else {
    return [model, new List()];
  }
}
export function view(model, dispatch) {
  if (model.tag === 1) {
    return view_1(model.data, $var1 => dispatch(function (arg0) {
      return new Shape(1, arg0);
    }($var1)));
  } else if (model.tag === 2) {
    return view_2(model.data, $var2 => dispatch(function (arg0_1) {
      return new Shape(2, arg0_1);
    }($var2)));
  } else {
    return view_3(model.data, $var3 => dispatch(function (arg0_2) {
      return new Shape(0, arg0_2);
    }($var3)));
  }
}