import { setType } from "../fable-core/Symbol";
import _Symbol from "../fable-core/Symbol";
import { createObj, equals, makeGeneric, comparePrimitives } from "../fable-core/Util";
import { view as view_1, update as update_1, Shape } from "../FilterInputs/CombinedFilterInput";
import { Message as Message_1 } from "../FilterInputs/FilterRangeInput";
import { Message as Message_2 } from "../FilterInputs/FilterColorInput";
import { Message as Message_3 } from "../FilterInputs/AnimatedFilterRangeInput";
import { choose, ofArray, map } from "../fable-core/List";
import List from "../fable-core/List";
import { printf, toText } from "../fable-core/String";
import { Cmd } from "../fable/cmd";
import { tryFind } from "../fable-core/Seq";
import { getValue } from "../fable-core/Option";
import { Props } from "../fable/Fable.Helpers.ReactNative";
import { Fragment, createElement } from "react";
import { Button, Text as _Text, View } from "react-native";
export class Input {
  constructor(tag) {
    this.tag = tag | 0;
  }

  [_Symbol.reflection]() {
    return {
      type: "MatrixFilterConstructor.Filter.Input",
      interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
      cases: [["Amount"], ["Desaturation"], ["Toned"], ["LightColor"], ["DarkColor"], ["Red"], ["Green"], ["Blue"], ["Alpha"], ["FirstColor"], ["SecondColor"]]
    };
  }

  Equals(other) {
    return this.tag === other.tag;
  }

  CompareTo(other) {
    return comparePrimitives(this.tag, other.tag);
  }

}
setType("MatrixFilterConstructor.Filter.Input", Input);
export class Message {
  constructor(tag, data) {
    this.tag = tag | 0;
    this.data = data;
  }

  [_Symbol.reflection]() {
    return {
      type: "MatrixFilterConstructor.Filter.Message",
      interfaces: ["FSharpUnion", "System.IEquatable"],
      cases: [["FilterInputMessage", Input, makeGeneric(Shape, {
        range: Message_1,
        color: Message_2,
        animated: Message_3
      })], ["MoveUp"], ["MoveDown"], ["Delete"], ["Tick"]]
    };
  }

  Equals(other) {
    return this === other || this.tag === other.tag && equals(this.data, other.data);
  }

}
setType("MatrixFilterConstructor.Filter.Message", Message);
export function init(inputs) {
  return map(function (tupledArg) {
    return [tupledArg[0], tupledArg[1](toText(printf("%A"))(tupledArg[0]))];
  }, inputs);
}
export function update(message, model) {
  switch (message.tag) {
    case 1:
    case 2:
    case 3:
      return [model, new List()];

    case 4:
      return [model, Cmd.batch(map(function (tupledArg) {
        return Cmd.map(function (sub) {
          return new Message(0, [tupledArg[0], sub]);
        }, Cmd.ofMsg(new Shape(2, new Message_3(1))));
      }, model))];

    default:
      const matchValue = tryFind(function (tupledArg_1) {
        return message.data[0].Equals(tupledArg_1[0]);
      }, model);

      if (matchValue == null) {
        return [model, new List()];
      } else {
        const inputModel = getValue(matchValue)[1];
        const patternInput = update_1(message.data[1], inputModel);
        return [map(function (tupledArg_2) {
          return [tupledArg_2[0], message.data[0].Equals(tupledArg_2[0]) ? patternInput[0] : tupledArg_2[1]];
        }, model), Cmd.map(function (sub_1) {
          return new Message(0, [message.data[0], sub_1]);
        }, patternInput[1])];
      }

  }
}
const controlsContainer = new Props.ViewProperties(8, ofArray([new Props.FlexStyle(37, 3), new Props.FlexStyle(24, 2), new Props.ImageStyle(7, 3), new Props.ImageStyle(6, 1), new Props.ImageStyle(4, "gainsboro")]));
const titleStyle = new Props.TextProperties(5, ofArray([new Props.TextStyle(4, "bold")]));
const controlButtonsStyle = new Props.ViewProperties(8, ofArray([new Props.FlexStyle(16, "row"), new Props.FlexStyle(21, "space-between")]));
export function view(filterComponent, mapInput, model, content) {
  return filterComponent(choose(function (x) {
    return x;
  }, function (list) {
    return map(mapInput, list);
  }(model)), ofArray([content]));
}
export function controls(name, model, dispatch) {
  const dispatch_ = $var1 => {
    return dispatch(function (tupledArg) {
      return new Message(0, [tupledArg[0], tupledArg[1]]);
    }($var1));
  };

  const sliders = map(function (tupledArg_1) {
    return view_1(tupledArg_1[1], function (msg) {
      dispatch_([tupledArg_1[0], msg]);
    });
  }, model);
  return createElement(View, createObj(ofArray([controlsContainer]), 1), createElement(_Text, createObj(ofArray([titleStyle]), 1), name), createElement(Fragment, {}, ...sliders), createElement(View, createObj(ofArray([controlButtonsStyle]), 1), createElement(Button, {
    title: "Move Up",
    onPress: function () {
      dispatch(new Message(1));
    }
  }), createElement(Button, {
    title: "Move Down",
    onPress: function () {
      dispatch(new Message(2));
    }
  }), createElement(Button, {
    title: "Delete",
    color: "red",
    onPress: function () {
      dispatch(new Message(3));
    }
  })));
}