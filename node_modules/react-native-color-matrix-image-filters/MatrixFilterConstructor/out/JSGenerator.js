import Choice from "./fable-core/Choice";
import { split, printf, toText, join, replace } from "./fable-core/String";
import { map as map_3, mapIndexed } from "./fable-core/Array";
import { name as name_1 } from "./Filters/CombinedFilter";
import { filter as filter_1, collect, ofArray, map as map_2 } from "./fable-core/List";
import { fold, toList, exists, mapFold } from "./fable-core/Seq";
import { defaultArg } from "./fable-core/Option";
import { create, add, tryFind } from "./fable-core/Map";
import Comparer from "./fable-core/Comparer";
import { comparePrimitives } from "./fable-core/Util";
import CurriedLambda from "./fable-core/CurriedLambda";
import { distinct } from "./fable-core/Set";
import { template as template_2 } from "./JSTemplateAnimated";
import { template as template_3 } from "./JSTemplate";
const imports = "__IMPORTS__";
const matrices = "__MATRICES__";
const props = "__PROPS__";
const initState = "__INITSTATE__";
const animate = "__ANIMATE__";
const state = "__STATE__";

function _Line_Imports_Props_Matrices_InitState_Animate_State_(input) {
  if (input.indexOf(imports) !== -1) {
    return new Choice(1, replace(input, imports, ""));
  } else if (input.indexOf(props) !== -1) {
    return new Choice(2, replace(input, props, ""));
  } else if (input.indexOf(matrices) !== -1) {
    return new Choice(3, replace(input, matrices, ""));
  } else if (input.indexOf(initState) !== -1) {
    return new Choice(4, replace(input, initState, ""));
  } else if (input.indexOf(animate) !== -1) {
    return new Choice(5, replace(input, animate, ""));
  } else if (input.indexOf(state) !== -1) {
    return new Choice(6, replace(input, state, ""));
  } else {
    return new Choice(0, input);
  }
}

function importName(filter) {
  return join("", mapIndexed(function (i, v) {
    return i === 0 ? v.toLocaleLowerCase() : v;
  }, replace(replace(name_1(filter), "Animated", ""), "RGBA", "rgba").split(""), Array));
}

function inputValue(input) {
  if (input.tag === 2) {
    return toText(printf("%.2f"))(input.data.Animated.Value);
  } else if (input.tag === 1) {
    return toText(printf("'%s'"))(input.data.Value);
  } else {
    return toText(printf("%.2f"))(input.data.Value);
  }
}

function inputMin(input) {
  if (input.tag === 2) {
    return toText(printf("%.2f"))(input.data.Animated.Min);
  } else {
    return "";
  }
}

function inputMax(input) {
  if (input.tag === 2) {
    return toText(printf("%.2f"))(input.data.Animated.Max);
  } else {
    return "";
  }
}

function stepValue(input) {
  if (input.tag === 2) {
    return toText(printf("%.2f"))(input.data.Step.Value);
  } else {
    return "0";
  }
}

function hasAnimated(_arg1, input) {
  if (input.tag === 2) {
    return true;
  } else {
    return false;
  }
}

export function run(selectedFilters) {
  var folder;
  const selectedFilters_1 = map_2(function (tupledArg) {
    return [tupledArg[0], tupledArg[1], tupledArg[2] === 1 ? "" : tupledArg[2].toString()];
  }, mapFold(function (map, tupledArg_1) {
    const name = importName(tupledArg_1[0]);
    const id = 1 + defaultArg(tryFind(name, map), 0) | 0;
    return [[name, tupledArg_1[1], id], add(name, id, map)];
  }, create(null, new Comparer(comparePrimitives)), selectedFilters, ofArray)[0]);

  const enumerateFilters = function (filterAnimated, map_1, padding) {
    return CurriedLambda(toText(printf("%s%s")))(padding)(join(toText(printf("\n%s"))(padding), function (list) {
      return map_2(map_1, list);
    }(collect(function (tupledArg_2) {
      return map_2(function (value) {
        return [tupledArg_2[0], value, tupledArg_2[2]];
      }, tupledArg_2[1]);
    }, filter_1(function (tupledArg_3) {
      return tupledArg_3[1].length > 0 ? filterAnimated(exists(function (tupledArg_4) {
        return hasAnimated(tupledArg_4[0], tupledArg_4[1]);
      }, tupledArg_3[1])) : false;
    }, selectedFilters_1)))));
  };

  const generate = function (_arg1) {
    const activePatternResult6478 = _Line_Imports_Props_Matrices_InitState_Animate_State_(_arg1);

    if (activePatternResult6478.tag === 4) {
      return enumerateFilters(function (x) {
        return x;
      }, function (tupledArg_5) {
        return tupledArg_5[1][0].tag === 0 ? toText(printf("%s%s: props.%s%s || 0,\n%s%sDirection%s: 1,"))(tupledArg_5[0], tupledArg_5[2], tupledArg_5[0], tupledArg_5[2], activePatternResult6478.data, tupledArg_5[0], tupledArg_5[2]) : "";
      }, activePatternResult6478.data);
    } else if (activePatternResult6478.tag === 5) {
      const declarations = enumerateFilters(function (x_1) {
        return x_1;
      }, function (tupledArg_6) {
        if (tupledArg_6[1][0].tag === 0) {
          const nameId = toText(printf("%s%s"))(tupledArg_6[0], tupledArg_6[2]);
          const min = toText(printf("(props.%sMin%s || %s)"))(tupledArg_6[0], tupledArg_6[2], inputMin(tupledArg_6[1][1]));
          const max = toText(printf("(props.%sMax%s || %s)"))(tupledArg_6[0], tupledArg_6[2], inputMax(tupledArg_6[1][1]));
          const dir = toText(printf("%sDirection%s"))(tupledArg_6[0], tupledArg_6[2]);
          const step = toText(printf("(props.%sStep%s || %s)"))(tupledArg_6[0], tupledArg_6[2], stepValue(tupledArg_6[1][1]));
          const firstLine = toText(printf("const %s = Math.max(%s, Math.min(%s, state.%s + state.%s * %s));"))(nameId, min, max, nameId, dir, step);
          const secondLine = toText(printf("const %s = %s === %s ? 1 : %s === %s ? -1 : state.%s;"))(dir, nameId, min, nameId, max, dir);
          return toText(printf("%s\n%s%s"))(firstLine, activePatternResult6478.data, secondLine);
        } else {
          return "";
        }
      }, activePatternResult6478.data);
      const state_1 = enumerateFilters(function (x_2) {
        return x_2;
      }, function (tupledArg_7) {
        return tupledArg_7[1][0].tag === 0 ? toText(printf("%s%s,\n%s  %sDirection%s,"))(tupledArg_7[0], tupledArg_7[2], activePatternResult6478.data, tupledArg_7[0], tupledArg_7[2]) : "";
      }, toText(printf("  %s"))(activePatternResult6478.data));
      return toText(printf("%s\n\n%sreturn {\n%s\n%s};"))(declarations, activePatternResult6478.data, state_1, activePatternResult6478.data);
    } else if (activePatternResult6478.tag === 6) {
      return enumerateFilters(function (x_3) {
        return x_3;
      }, function (tupledArg_8) {
        return tupledArg_8[1][0].tag === 0 ? toText(printf("%s%s: %sValue%s,"))(tupledArg_8[0], tupledArg_8[2], tupledArg_8[0], tupledArg_8[2]) : "";
      }, activePatternResult6478.data);
    } else if (activePatternResult6478.tag === 2) {
      return enumerateFilters(function (value_1) {
        return !value_1;
      }, function (tupledArg_9) {
        return tupledArg_9[1][0].tag === 0 ? toText(printf("%s%s: %sValue%s = %s,"))(tupledArg_9[0], tupledArg_9[2], tupledArg_9[0], tupledArg_9[2], inputValue(tupledArg_9[1][1])) : toText(printf("%s%A%s = %s"))(tupledArg_9[0], tupledArg_9[1][0], tupledArg_9[2], inputValue(tupledArg_9[1][1]));
      }, activePatternResult6478.data);
    } else if (activePatternResult6478.tag === 3) {
      return CurriedLambda(toText(printf("%s%s")))(activePatternResult6478.data)(join(toText(printf(",\n%s"))(activePatternResult6478.data), map_2(function (tupledArg_10) {
        return tupledArg_10[1].length > 0 ? CurriedLambda(toText(printf("%s(%s)")))(tupledArg_10[0])(function (valueNames) {
          return join(", ", valueNames);
        }(map_2(function (tupledArg_11) {
          return toText(printf("%s%A%s"))(tupledArg_10[0], tupledArg_11[0], tupledArg_10[2]);
        }, tupledArg_10[1]))) : toText(printf("%s()"))(tupledArg_10[0]);
      }, selectedFilters_1)));
    } else if (activePatternResult6478.tag === 0) {
      return activePatternResult6478.data;
    } else {
      return CurriedLambda(toText(printf("%s%s")))(activePatternResult6478.data)(join(toText(printf(",\n%s"))(activePatternResult6478.data), toList(distinct(map_2(function (tupledArg_12) {
        return tupledArg_12[0];
      }, selectedFilters_1)))));
    }
  };

  return join("\n", function (array) {
    return map_3(generate, array, Array);
  }(function (template) {
    return split(template, ["\n"], null, 0);
  }((folder = function (template_1, input) {
    return hasAnimated(input[0], input[1]) ? template_2 : template_1;
  }, function (list_1) {
    return fold(folder, template_3, list_1);
  })(collect(function (tupledArg_13) {
    return tupledArg_13[1];
  }, selectedFilters_1)))));
}